This is a simple example showing how to use spring-data-dynamodb to create a domain model and a repository class that will perform basic CRUD operations.  We will model a DynamoDB table that stores customer information for a shopping cart system.

In general, the dynamo annotations that you have read about in the [AWS Developer documentation](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.Annotations.html) are exactly what you will be using with dynamodb.  The only major difference is when you have both a [hash key and a range key](/derjust/spring-data-dynamodb/wiki/Use-Hash-Range-keys).

### Dynamo DB Table

To start, we will need a unique identifier, an email address, and both the first and last name of the customer.  Lastly, we will need to find a customer by their unique identifier.  This is pretty simple and if you defined it as a DynamoDB table it would look like this:

```json
{
  "AttributeDefinitions": [
    {
      "AttributeName": "id",
      "AttributeType": "S"
    },
    {
      "AttributeName": "emailAddress",
      "AttributeType": "S"
    },
    {
      "AttributeName": "firstName",
      "AttributeType": "S"
    },
    {
      "AttributeName": "lastName",
      "AttributeType": "S"
    }
   ],
  "KeySchema": [
    {
      "AttributeName": "id",
      "KeyType": "HASH"
    }
  ],
  "ProvisionedThroughput": {
    "ReadCapacityUnits": "10",
    "WriteCapacityUnits": "10"
  },
  "TableName": "customer"
}
```

### Domain Model

The definition above translates pretty simply into a domain model object like this:

```java
@DynamoDBTable( tableName = "customer" )
public class Customer {

	@Id
    @DynamoDBHashKey
    @DynamoDBAutoGeneratedKey
	private String id;
	
	private String emailAddress;
	private String firstName;
	private String lastName;

	public Customer(String id, String emailAddress, String firstName, String lastName) {
		this.id = id;
		this.emailAddress = emailAddress;
		this.firstName = firstName;
		this.lastName = lastName;
	}

	public string getid() {
		return id;
	}

	public string setid(string id) {
		this.id = id;
	}

	public string getemailaddress() {
		return emailaddress;
	}

	public string setemailaddress(string emailaddress) {
		this.emailaddress = emailaddress;
	}

	public string getfirstname() {
		return firstname;
	}

	public string setfirstname(string firstname) {
		this.firstname = firstname;
	}

	public string getlastname() {
		return lastname;
	}

	public string setlastname(string lastname) {
		this.lastname = lastname;
	}
}
```

There are a few things to note in the class above:
* @DynamoDBTable is a class level annotation which provides the table name.
* The id field is marked with a few different annotations.
  * @DynamoDBHashKey marks the id field as the hash key for the table.
  * @DynamoDBAutoGeneratedKey marks the field as an auto generated key so the AWS client side library will generate a UUID for this field.
  * @Id is a spring-data annotation which tells spring-data that the id field acts as a primary key and will be used in repository methods like findOne.  This isn't strictly necessary in this example, but can be a good habit to get into.

### Repository

Finally, we will create a simple repository so we can perform basic CRUD operations on the DynamoDB table.  We extend the spring-data CrudRespository interface to specify that operations are performed on the Customer class and that the identifier used for methods like findOne is of type String.  Here is what the CustomerRepository class looks like:

```java
public interface CustomerRepository extends CrudRepository<Customer, String> {

}
```
### Conclusion

That's about all we need to do to create a respository that supports basic CRUD operations for a table with only a hash key.